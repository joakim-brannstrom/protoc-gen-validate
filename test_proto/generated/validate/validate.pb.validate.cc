// Code generated by protoc-gen-validate
// source: validate/validate.proto
// DO NOT EDIT!!!

#include "validate/validate.pb.validate.h"

#include <google/protobuf/message.h>
#include <google/protobuf/util/time_util.h>

namespace pgv {

namespace protobuf = google::protobuf;
namespace protobuf_wkt = google::protobuf;

namespace validate {
using std::string;

pgv::Validator<::validate::FieldRules> validator___validate__FieldRules(static_cast<bool(*)(const ::validate::FieldRules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::FloatRules> validator___validate__FloatRules(static_cast<bool(*)(const ::validate::FloatRules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::DoubleRules> validator___validate__DoubleRules(static_cast<bool(*)(const ::validate::DoubleRules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::Int32Rules> validator___validate__Int32Rules(static_cast<bool(*)(const ::validate::Int32Rules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::Int64Rules> validator___validate__Int64Rules(static_cast<bool(*)(const ::validate::Int64Rules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::UInt32Rules> validator___validate__UInt32Rules(static_cast<bool(*)(const ::validate::UInt32Rules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::UInt64Rules> validator___validate__UInt64Rules(static_cast<bool(*)(const ::validate::UInt64Rules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::SInt32Rules> validator___validate__SInt32Rules(static_cast<bool(*)(const ::validate::SInt32Rules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::SInt64Rules> validator___validate__SInt64Rules(static_cast<bool(*)(const ::validate::SInt64Rules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::Fixed32Rules> validator___validate__Fixed32Rules(static_cast<bool(*)(const ::validate::Fixed32Rules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::Fixed64Rules> validator___validate__Fixed64Rules(static_cast<bool(*)(const ::validate::Fixed64Rules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::SFixed32Rules> validator___validate__SFixed32Rules(static_cast<bool(*)(const ::validate::SFixed32Rules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::SFixed64Rules> validator___validate__SFixed64Rules(static_cast<bool(*)(const ::validate::SFixed64Rules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::BoolRules> validator___validate__BoolRules(static_cast<bool(*)(const ::validate::BoolRules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::StringRules> validator___validate__StringRules(static_cast<bool(*)(const ::validate::StringRules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::BytesRules> validator___validate__BytesRules(static_cast<bool(*)(const ::validate::BytesRules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::EnumRules> validator___validate__EnumRules(static_cast<bool(*)(const ::validate::EnumRules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::MessageRules> validator___validate__MessageRules(static_cast<bool(*)(const ::validate::MessageRules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::RepeatedRules> validator___validate__RepeatedRules(static_cast<bool(*)(const ::validate::RepeatedRules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::MapRules> validator___validate__MapRules(static_cast<bool(*)(const ::validate::MapRules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::AnyRules> validator___validate__AnyRules(static_cast<bool(*)(const ::validate::AnyRules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::DurationRules> validator___validate__DurationRules(static_cast<bool(*)(const ::validate::DurationRules&, pgv::ValidationLog*)>(::validate::validate));
pgv::Validator<::validate::TimestampRules> validator___validate__TimestampRules(static_cast<bool(*)(const ::validate::TimestampRules&, pgv::ValidationLog*)>(::validate::validate));


} // namespace validate
} // namespace pgv


namespace validate {


// Validate checks the field values on ::validate::FieldRules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::FieldRules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::FieldRules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;
	
	
	

	
	{
		if (m.has_message() && !pgv::BaseValidator::AbstractCheckMessage(m.message(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Message"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

		
			switch (m.type_case()) {
				case ::validate::FieldRules::TypeCase::kFloat:
						
	
	
	

	
	{
		if (m.has_float() && !pgv::BaseValidator::AbstractCheckMessage(m.float(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Float"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				case ::validate::FieldRules::TypeCase::kDouble:
						
	
	
	

	
	{
		if (m.has_double() && !pgv::BaseValidator::AbstractCheckMessage(m.double(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Double"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				case ::validate::FieldRules::TypeCase::kInt32:
						
	
	
	

	
	{
		if (m.has_int32() && !pgv::BaseValidator::AbstractCheckMessage(m.int32(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Int32"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				case ::validate::FieldRules::TypeCase::kInt64:
						
	
	
	

	
	{
		if (m.has_int64() && !pgv::BaseValidator::AbstractCheckMessage(m.int64(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Int64"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				case ::validate::FieldRules::TypeCase::kUint32:
						
	
	
	

	
	{
		if (m.has_uint32() && !pgv::BaseValidator::AbstractCheckMessage(m.uint32(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Uint32"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				case ::validate::FieldRules::TypeCase::kUint64:
						
	
	
	

	
	{
		if (m.has_uint64() && !pgv::BaseValidator::AbstractCheckMessage(m.uint64(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Uint64"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				case ::validate::FieldRules::TypeCase::kSint32:
						
	
	
	

	
	{
		if (m.has_sint32() && !pgv::BaseValidator::AbstractCheckMessage(m.sint32(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Sint32"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				case ::validate::FieldRules::TypeCase::kSint64:
						
	
	
	

	
	{
		if (m.has_sint64() && !pgv::BaseValidator::AbstractCheckMessage(m.sint64(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Sint64"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				case ::validate::FieldRules::TypeCase::kFixed32:
						
	
	
	

	
	{
		if (m.has_fixed32() && !pgv::BaseValidator::AbstractCheckMessage(m.fixed32(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Fixed32"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				case ::validate::FieldRules::TypeCase::kFixed64:
						
	
	
	

	
	{
		if (m.has_fixed64() && !pgv::BaseValidator::AbstractCheckMessage(m.fixed64(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Fixed64"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				case ::validate::FieldRules::TypeCase::kSfixed32:
						
	
	
	

	
	{
		if (m.has_sfixed32() && !pgv::BaseValidator::AbstractCheckMessage(m.sfixed32(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Sfixed32"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				case ::validate::FieldRules::TypeCase::kSfixed64:
						
	
	
	

	
	{
		if (m.has_sfixed64() && !pgv::BaseValidator::AbstractCheckMessage(m.sfixed64(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Sfixed64"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				case ::validate::FieldRules::TypeCase::kBool:
						
	
	
	

	
	{
		if (m.has_bool() && !pgv::BaseValidator::AbstractCheckMessage(m.bool(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Bool"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				case ::validate::FieldRules::TypeCase::kString:
						
	
	
	

	
	{
		if (m.has_string() && !pgv::BaseValidator::AbstractCheckMessage(m.string(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "String"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				case ::validate::FieldRules::TypeCase::kBytes:
						
	
	
	

	
	{
		if (m.has_bytes() && !pgv::BaseValidator::AbstractCheckMessage(m.bytes(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Bytes"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				case ::validate::FieldRules::TypeCase::kEnum:
						
	
	
	

	
	{
		if (m.has_enum() && !pgv::BaseValidator::AbstractCheckMessage(m.enum(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Enum"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				case ::validate::FieldRules::TypeCase::kRepeated:
						
	
	
	

	
	{
		if (m.has_repeated() && !pgv::BaseValidator::AbstractCheckMessage(m.repeated(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Repeated"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				case ::validate::FieldRules::TypeCase::kMap:
						
	
	
	

	
	{
		if (m.has_map() && !pgv::BaseValidator::AbstractCheckMessage(m.map(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Map"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				case ::validate::FieldRules::TypeCase::kAny:
						
	
	
	

	
	{
		if (m.has_any() && !pgv::BaseValidator::AbstractCheckMessage(m.any(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Any"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				case ::validate::FieldRules::TypeCase::kDuration:
						
	
	
	

	
	{
		if (m.has_duration() && !pgv::BaseValidator::AbstractCheckMessage(m.duration(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Duration"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				case ::validate::FieldRules::TypeCase::kTimestamp:
						
	
	
	

	
	{
		if (m.has_timestamp() && !pgv::BaseValidator::AbstractCheckMessage(m.timestamp(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"FieldRulesValidationError" "." "Timestamp"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

						break;
				default:
					break;
			}
		
	return true;
}

// Validate checks the field values on ::validate::FloatRules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::FloatRules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::FloatRules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for const// no validation rules for lt// no validation rules for lte// no validation rules for gt// no validation rules for gte
	
	
	

	

	
	

	
	
	

	

	
	
// no validation rules for ignore_empty
		
	return true;
}

// Validate checks the field values on ::validate::DoubleRules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::DoubleRules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::DoubleRules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for const// no validation rules for lt// no validation rules for lte// no validation rules for gt// no validation rules for gte
	
	
	

	

	
	

	
	
	

	

	
	
// no validation rules for ignore_empty
		
	return true;
}

// Validate checks the field values on ::validate::Int32Rules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::Int32Rules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::Int32Rules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for const// no validation rules for lt// no validation rules for lte// no validation rules for gt// no validation rules for gte
	
	
	

	

	
	

	
	
	

	

	
	
// no validation rules for ignore_empty
		
	return true;
}

// Validate checks the field values on ::validate::Int64Rules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::Int64Rules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::Int64Rules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for const// no validation rules for lt// no validation rules for lte// no validation rules for gt// no validation rules for gte
	
	
	

	

	
	

	
	
	

	

	
	
// no validation rules for ignore_empty
		
	return true;
}

// Validate checks the field values on ::validate::UInt32Rules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::UInt32Rules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::UInt32Rules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for const// no validation rules for lt// no validation rules for lte// no validation rules for gt// no validation rules for gte
	
	
	

	

	
	

	
	
	

	

	
	
// no validation rules for ignore_empty
		
	return true;
}

// Validate checks the field values on ::validate::UInt64Rules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::UInt64Rules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::UInt64Rules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for const// no validation rules for lt// no validation rules for lte// no validation rules for gt// no validation rules for gte
	
	
	

	

	
	

	
	
	

	

	
	
// no validation rules for ignore_empty
		
	return true;
}

// Validate checks the field values on ::validate::SInt32Rules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::SInt32Rules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::SInt32Rules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for const// no validation rules for lt// no validation rules for lte// no validation rules for gt// no validation rules for gte
	
	
	

	

	
	

	
	
	

	

	
	
// no validation rules for ignore_empty
		
	return true;
}

// Validate checks the field values on ::validate::SInt64Rules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::SInt64Rules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::SInt64Rules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for const// no validation rules for lt// no validation rules for lte// no validation rules for gt// no validation rules for gte
	
	
	

	

	
	

	
	
	

	

	
	
// no validation rules for ignore_empty
		
	return true;
}

// Validate checks the field values on ::validate::Fixed32Rules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::Fixed32Rules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::Fixed32Rules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for const// no validation rules for lt// no validation rules for lte// no validation rules for gt// no validation rules for gte
	
	
	

	

	
	

	
	
	

	

	
	
// no validation rules for ignore_empty
		
	return true;
}

// Validate checks the field values on ::validate::Fixed64Rules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::Fixed64Rules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::Fixed64Rules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for const// no validation rules for lt// no validation rules for lte// no validation rules for gt// no validation rules for gte
	
	
	

	

	
	

	
	
	

	

	
	
// no validation rules for ignore_empty
		
	return true;
}

// Validate checks the field values on ::validate::SFixed32Rules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::SFixed32Rules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::SFixed32Rules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for const// no validation rules for lt// no validation rules for lte// no validation rules for gt// no validation rules for gte
	
	
	

	

	
	

	
	
	

	

	
	
// no validation rules for ignore_empty
		
	return true;
}

// Validate checks the field values on ::validate::SFixed64Rules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::SFixed64Rules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::SFixed64Rules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for const// no validation rules for lt// no validation rules for lte// no validation rules for gt// no validation rules for gte
	
	
	

	

	
	

	
	
	

	

	
	
// no validation rules for ignore_empty
		
	return true;
}

// Validate checks the field values on ::validate::BoolRules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	



bool validate(const ::validate::BoolRules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::BoolRules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for const
		
	return true;
}

// Validate checks the field values on ::validate::StringRules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::StringRules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::StringRules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for const// no validation rules for len// no validation rules for min_len// no validation rules for max_len// no validation rules for len_bytes// no validation rules for min_bytes// no validation rules for max_bytes// no validation rules for pattern// no validation rules for prefix// no validation rules for suffix// no validation rules for contains// no validation rules for not_contains
	
	
	

	

	
	

	
	
	

	

	
	
// no validation rules for strict// no validation rules for ignore_empty
		
			switch (m.well_known_case()) {
				case ::validate::StringRules::WellKnownCase::kEmail:
						// no validation rules for email
						break;
				case ::validate::StringRules::WellKnownCase::kHostname:
						// no validation rules for hostname
						break;
				case ::validate::StringRules::WellKnownCase::kIp:
						// no validation rules for ip
						break;
				case ::validate::StringRules::WellKnownCase::kIpv4:
						// no validation rules for ipv4
						break;
				case ::validate::StringRules::WellKnownCase::kIpv6:
						// no validation rules for ipv6
						break;
				case ::validate::StringRules::WellKnownCase::kUri:
						// no validation rules for uri
						break;
				case ::validate::StringRules::WellKnownCase::kUriRef:
						// no validation rules for uri_ref
						break;
				case ::validate::StringRules::WellKnownCase::kAddress:
						// no validation rules for address
						break;
				case ::validate::StringRules::WellKnownCase::kUuid:
						// no validation rules for uuid
						break;
				case ::validate::StringRules::WellKnownCase::kWellKnownRegex:
						// no validation rules for well_known_regex
						break;
				default:
					break;
			}
		
	return true;
}

// Validate checks the field values on ::validate::BytesRules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::BytesRules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::BytesRules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for const// no validation rules for len// no validation rules for min_len// no validation rules for max_len// no validation rules for pattern// no validation rules for prefix// no validation rules for suffix// no validation rules for contains
	
	
	

	

	
	

	
	
	

	

	
	
// no validation rules for ignore_empty
		
			switch (m.well_known_case()) {
				case ::validate::BytesRules::WellKnownCase::kIp:
						// no validation rules for ip
						break;
				case ::validate::BytesRules::WellKnownCase::kIpv4:
						// no validation rules for ipv4
						break;
				case ::validate::BytesRules::WellKnownCase::kIpv6:
						// no validation rules for ipv6
						break;
				default:
					break;
			}
		
	return true;
}

// Validate checks the field values on ::validate::EnumRules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::EnumRules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::EnumRules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for const// no validation rules for defined_only
	
	
	

	

	
	

	
	
	

	

	
	

		
	return true;
}

// Validate checks the field values on ::validate::MessageRules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::MessageRules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::MessageRules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for skip// no validation rules for required
		
	return true;
}

// Validate checks the field values on ::validate::RepeatedRules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::RepeatedRules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::RepeatedRules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for min_items// no validation rules for max_items// no validation rules for unique
	
	
	

	
	{
		if (m.has_items() && !pgv::BaseValidator::AbstractCheckMessage(m.items(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"RepeatedRulesValidationError" "." "Items"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	
// no validation rules for ignore_empty
		
	return true;
}

// Validate checks the field values on ::validate::MapRules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::MapRules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::MapRules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for min_pairs// no validation rules for max_pairs// no validation rules for no_sparse
	
	
	

	
	{
		if (m.has_keys() && !pgv::BaseValidator::AbstractCheckMessage(m.keys(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"MapRulesValidationError" "." "Keys"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

	
	
	

	
	{
		if (m.has_values() && !pgv::BaseValidator::AbstractCheckMessage(m.values(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"MapRulesValidationError" "." "Values"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	
// no validation rules for ignore_empty
		
	return true;
}

// Validate checks the field values on ::validate::AnyRules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::AnyRules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::AnyRules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for required
	
	
	

	

	
	

	
	
	

	

	
	

		
	return true;
}

// Validate checks the field values on ::validate::DurationRules with the rules
// defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::DurationRules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::DurationRules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for required
	
	
	

	
	{
		if (m.has_const_() && !pgv::BaseValidator::AbstractCheckMessage(m.const_(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"DurationRulesValidationError" "." "Const"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

	
	
	

	
	{
		if (m.has_lt() && !pgv::BaseValidator::AbstractCheckMessage(m.lt(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"DurationRulesValidationError" "." "Lt"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

	
	
	

	
	{
		if (m.has_lte() && !pgv::BaseValidator::AbstractCheckMessage(m.lte(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"DurationRulesValidationError" "." "Lte"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

	
	
	

	
	{
		if (m.has_gt() && !pgv::BaseValidator::AbstractCheckMessage(m.gt(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"DurationRulesValidationError" "." "Gt"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

	
	
	

	
	{
		if (m.has_gte() && !pgv::BaseValidator::AbstractCheckMessage(m.gte(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"DurationRulesValidationError" "." "Gte"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

	
	
	

	

	
		for (int i = 0; i < m.in().size(); i++) {
			const auto& item = m.in().Get(i);
			(void)item;

			

			
	
	
	

	
	{
		if (true && !pgv::BaseValidator::AbstractCheckMessage(item, err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"DurationRulesValidationError" "." "In"
"[" i "]"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

		}
	
	

	
	
	

	

	
		for (int i = 0; i < m.not_in().size(); i++) {
			const auto& item = m.not_in().Get(i);
			(void)item;

			

			
	
	
	

	
	{
		if (true && !pgv::BaseValidator::AbstractCheckMessage(item, err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"DurationRulesValidationError" "." "NotIn"
"[" i "]"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

		}
	
	

		
	return true;
}

// Validate checks the field values on ::validate::TimestampRules with the
// rules defined in the proto definition for this message. If any rules are
// violated, the return value is false and an error message is written to the
// input string argument.

	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	


	

	

	

	
        

	

	

	



bool validate(const ::validate::TimestampRules& m) {
    return validate(m, nullptr);
}

bool validate(const ::validate::TimestampRules& m, pgv::ValidationLog* err) {
	(void)m;
	(void)err;// no validation rules for required
	
	
	

	
	{
		if (m.has_const_() && !pgv::BaseValidator::AbstractCheckMessage(m.const_(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"TimestampRulesValidationError" "." "Const"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

	
	
	

	
	{
		if (m.has_lt() && !pgv::BaseValidator::AbstractCheckMessage(m.lt(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"TimestampRulesValidationError" "." "Lt"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

	
	
	

	
	{
		if (m.has_lte() && !pgv::BaseValidator::AbstractCheckMessage(m.lte(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"TimestampRulesValidationError" "." "Lte"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

	
	
	

	
	{
		if (m.has_gt() && !pgv::BaseValidator::AbstractCheckMessage(m.gt(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"TimestampRulesValidationError" "." "Gt"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

	
	
	

	
	{
		if (m.has_gte() && !pgv::BaseValidator::AbstractCheckMessage(m.gte(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"TimestampRulesValidationError" "." "Gte"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	
// no validation rules for lt_now// no validation rules for gt_now
	
	
	

	
	{
		if (m.has_within() && !pgv::BaseValidator::AbstractCheckMessage(m.within(), err)) {
            if (err) { err->embedded(); }
			{
if (err) {
const char* errMsg = 
"TimestampRulesValidationError" "." "Within"
": " "embedded message failed validation"
;
err->log(errMsg);
err->done();
}
return false;
}
		}
	}
	

		
	return true;
}


} // namespace

